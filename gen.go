package plasmactlupdate

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/launchrctl/launchr"
	"gopkg.in/yaml.v3"
)

const (
	// @todo replace after migration.
	pkgPath             = "github.com/skilld-labs/plasmactl-update"
	lookupConfigNameTpl = "%s-update.yaml"
	pluginDirTpl        = "%s-update-plugin"
	storedConfigName    = "config.yaml"
)

// Generate implements [launchr.GeneratePlugin] interface.
func (p *Plugin) Generate(config launchr.GenerateConfig) error {
	launchr.Term().Info().Printfln("Preparing %s assets...", pkgPath)
	pluginDir := fmt.Sprintf(pluginDirTpl, launchr.Version().Name)
	processConfigFile(config.WorkDir, filepath.Join(config.BuildDir, pluginDir))

	// Prepare the generated plugin with embed assets.
	launchr.Term().Info().Printfln("Generating %s embed assets go file", pkgPath)
	type templateVars struct {
		Pkg        string
		ConfigPath string
	}
	tpl := launchr.Template{Tmpl: pluginTemplate, Data: templateVars{
		Pkg:        pkgPath,
		ConfigPath: filepath.Join(pluginDir, storedConfigName),
	}}

	assetsFilename := fmt.Sprintf("%s_update_assets.gen.go", launchr.Version().Name)
	err := tpl.WriteFile(filepath.Join(config.BuildDir, assetsFilename))
	if err != nil {
		return err
	}

	return nil
}

// processConfigFile checks for config existence, validates it, and handles file operations
func processConfigFile(sourceFolder, targetPath string) {
	localConfig := filepath.Join(sourceFolder, fmt.Sprintf(lookupConfigNameTpl, launchr.Version().Name))
	configPath := filepath.Join(targetPath, storedConfigName)

	// Try to get an existing config file and copy to assets dir.
	err := getExistingConfig(localConfig, configPath)
	if err == nil {
		return
	}

	// Fallback to create an empty config file.
	launchr.Term().Printfln(err.Error())
	createDefaultConfigFile(configPath)
}

func getExistingConfig(localConfig, configPath string) error {
	// Check if a config file exists in the working directory
	if _, err := os.Stat(localConfig); os.IsNotExist(err) {
		return fmt.Errorf("config file does not exist in work dir %s", localConfig)
	}

	// Try to parse an existing config file and validate
	_, err := parseConfigFromPath(localConfig)
	if err != nil {
		return fmt.Errorf("error parsing config file %s: %v", localConfig, err)
	}

	// Copy a config file if no error
	if err = copyFile(localConfig, configPath); err != nil {
		return fmt.Errorf("error copying config file from %s to %s: %v", localConfig, configPath, err)
	}

	launchr.Log().Debug(fmt.Sprintf("Config file successfully copied from %s to %s", localConfig, configPath))

	return nil
}

func copyFile(src, dst string) error {
	err := launchr.EnsurePath(filepath.Dir(dst))
	if err != nil {
		return err
	}

	sourceFile, err := os.Open(filepath.Clean(src))
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

func createDefaultConfigFile(path string) {
	defaultConfig := &config{
		RepositoryURL: "",
		PinnedRelease: "",
		BinMask:       "",
	}

	err := launchr.EnsurePath(filepath.Dir(path))
	if err != nil {
		launchr.Term().Printfln("Error creating assets dir: %v", err)
		return
	}

	data, err := yaml.Marshal(defaultConfig)
	if err != nil {
		launchr.Term().Printfln("Error marshaling default config: %v", err)
		return
	}

	if err = os.WriteFile(path, data, 0600); err != nil {
		launchr.Term().Printfln("Error creating default config file at %s: %v", path, err)
		return
	}

	launchr.Term().Printfln("Empty config file created at %s", path)
}

const pluginTemplate = `// Code generated by {{.Pkg}}. DO NOT EDIT.
package main

import (
	_ "embed"

	update "{{.Pkg}}"
)

//go:embed {{.ConfigPath}}
var launchrUpdateConfig []byte

func init() {
	_ = update.LoadConfigFromBytesAndSet(launchrUpdateConfig)
}
`
