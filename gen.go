package plasmactlupdate

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/launchrctl/launchr"
	"gopkg.in/yaml.v3"
)

const (
	pkgPath    = "github.com/skilld-labs/plasmactl-update"
	configName = "plasmactl-update.yaml"
	subDir     = "plasmactl-update-plugin"
)

// Generate implements [launchr.GeneratePlugin] interface.
func (p *Plugin) Generate(config launchr.GenerateConfig) error {
	launchr.Term().Info().Println("Preparing plasmactl-update plugin assets...")

	processConfigFile(config.WorkDir, filepath.Join(config.BuildDir, subDir))

	// Prepare the generated plugin with embed assets.
	launchr.Term().Info().Println("Generating plasmactl-update embed assets go file")
	type templateVars struct {
		Pkg        string
		ClientPath string
	}
	tpl := launchr.Template{Tmpl: pluginTemplate, Data: templateVars{
		Pkg:        pkgPath,
		ClientPath: subDir,
	}}
	err := tpl.WriteFile(filepath.Join(config.BuildDir, "plasmactl_update_assets.gen.go"))
	if err != nil {
		return err
	}

	return nil
}

// processConfigFile checks for config existence, validates it, and handles file operations
func processConfigFile(sourceFolder, targetPath string) {
	localConfig := filepath.Join(sourceFolder, configName)
	configPath := filepath.Join(targetPath, configName)

	// Try to get an existing config file and copy to assets dir.
	err := getExistingConfig(localConfig, configPath)
	if err == nil {
		return
	}

	// Fallback to create an empty config file.
	launchr.Term().Printfln(err.Error())
	createDefaultConfigFile(configPath)
}

func getExistingConfig(localConfig, configPath string) error {
	// Check if a config file exists in the working directory
	if _, err := os.Stat(localConfig); os.IsNotExist(err) {
		return fmt.Errorf("config file does not exist in work dir %s", localConfig)
	}

	// Try to parse an existing config file and validate
	_, err := parseConfigFromPath(localConfig)
	if err != nil {
		return fmt.Errorf("error parsing config file %s: %v", localConfig, err)
	}

	// Copy a config file if no error
	if err = copyFile(localConfig, configPath); err != nil {
		return fmt.Errorf("error copying config file from %s to %s: %v", localConfig, configPath, err)
	}

	launchr.Term().Printfln("Config file successfully copied from %s to %s", localConfig, configPath)

	return nil
}

func copyFile(src, dst string) error {
	err := launchr.EnsurePath(filepath.Dir(dst))
	if err != nil {
		return err
	}

	sourceFile, err := os.Open(filepath.Clean(src))
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

func createDefaultConfigFile(path string) {
	defaultConfig := &config{
		RepositoryURL: "",
		LatestStable:  "",
		BinMask:       "",
	}

	err := launchr.EnsurePath(filepath.Dir(path))
	if err != nil {
		launchr.Term().Printfln("Error creating assets dir: %v", err)
		return
	}

	data, err := yaml.Marshal(defaultConfig)
	if err != nil {
		launchr.Term().Printfln("Error marshaling default config: %v", err)
		return
	}

	if err = os.WriteFile(path, data, 0600); err != nil {
		launchr.Term().Printfln("Error creating default config file at %s: %v", path, err)
		return
	}

	launchr.Term().Printfln("Empty config file created at %s", path)
}

const pluginTemplate = `// Code generated by {{.Pkg}}. DO NOT EDIT.
package main

import (
	_ "embed"

	update "{{.Pkg}}"
)

//go:embed {{.ClientPath}}/plasmactl-update.yaml
var plasmactlUpdateConfig []byte

func init() {
	_ = update.LoadConfigFromBytesAndSet(plasmactlUpdateConfig)
}
`
